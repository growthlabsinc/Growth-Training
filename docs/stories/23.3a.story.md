# Story 23.3a: Local Subscription State Management

## Status: âœ… COMPLETE (January 19, 2025)

## Story

- As a **Growth app user**
- I want **my subscription status to be consistently maintained locally across app sessions**
- so that **I can reliably access my subscribed features without interruption when offline or during network issues**

**Context:** This story implements the local state management portion of the original Story 23.3, focusing on coordinating subscription state between StoreKit 2 (Story 23.2) and the existing SubscriptionEntitlementService. This creates a foundation for consistent subscription state without requiring server validation, enabling immediate development progress while Story 23.4 infrastructure dependencies are resolved.

## Background

With StoreKit 2 integration (Story 23.2) providing purchase capabilities and the existing SubscriptionEntitlementService handling feature access, we need a local state coordination service that bridges StoreKit transaction monitoring with our entitlement system. This service will operate entirely with local validation until server infrastructure from Story 23.4 is available.

## Acceptance Criteria

### Core Local State Management
- [ ] Create SubscriptionStateManager service that monitors StoreKit transaction updates locally
- [ ] Implement automatic subscription state synchronization on app launch using local StoreKit data
- [ ] Provide real-time subscription status updates to UI components via Combine publishers
- [ ] Handle subscription expiration and renewal notifications from local StoreKit monitoring
- [ ] Manage subscription state persistence across app sessions using UserDefaults caching

### Local Service Integration
- [ ] Integrate with existing SubscriptionEntitlementService for feature access validation without breaking changes
- [ ] Coordinate with StoreKitService for transaction monitoring using local validation only
- [ ] Cache subscription state locally with proper timestamp-based invalidation
- [ ] Handle offline scenarios gracefully by relying on local StoreKit transaction history
- [ ] Synchronize local state between SubscriptionStateManager and SubscriptionEntitlementService

### Error Handling & Fallbacks
- [ ] Provide fallback mechanisms when StoreKit is unavailable using cached state
- [ ] Handle iOS version compatibility with appropriate fallbacks for pre-iOS 15.0 devices
- [ ] Log state management errors for debugging without server dependencies
- [ ] Implement proper Task cancellation and memory management for async monitoring

### App Lifecycle Integration
- [ ] Integrate with app lifecycle events (foreground/background) for state refresh
- [ ] Support paywalls and subscription UI components with real-time state updates
- [ ] Ensure proper initialization order with existing services during app startup
- [ ] Handle app termination and state persistence gracefully

## Technical Implementation

### Service Architecture
```swift
@available(iOS 15.0, *)
class SubscriptionStateManager: ObservableObject {
    @Published var subscriptionState: SubscriptionState
    @Published var isLoading: Bool
    @Published var lastError: Error?
    
    private let storeKitService: StoreKitService
    private let entitlementService: SubscriptionEntitlementService
    private var transactionUpdateTask: Task<Void, Never>?
    private let localCache: SubscriptionStateCache
    
    // Local validation only - no server calls
    func validateSubscriptionLocally() async -> SubscriptionState
}
```

### State Model
```swift
struct SubscriptionState: Codable {
    let tier: SubscriptionTier
    let status: SubscriptionStatus  // active, expired, trial, cancelled
    let expirationDate: Date?
    let isTrialActive: Bool
    let autoRenewalEnabled: Bool
    let lastUpdated: Date
    let validationSource: ValidationSource // local, cached, server
}

enum ValidationSource: String, Codable {
    case local = "local"
    case cached = "cached"
    case server = "server"  // Not used in 23.3a
}
```

### Local Integration Points
- Consume StoreKit transaction updates from StoreKitService for local validation
- Update SubscriptionEntitlementService when local state changes
- Provide state to subscription UI components via Combine publishers
- Cache state locally using UserDefaults with proper versioning

## Dev Technical Guidance

### Previous Story Insights
Based on Story 23.2 completion, we have established StoreKitService patterns for transaction monitoring and PurchaseManager for purchase orchestration. [Source: ai/stories/23.2.story.md]

### iOS Architecture Context
- **Platform**: iOS with Swift 5.10+, SwiftUI for UI components [Source: Technology Stack Specification.md]
- **State Management**: Use SwiftUI `@StateObject`/`@ObservedObject` patterns with Combine publishers [Source: CLAUDE.md#Key Patterns and Conventions]
- **Service Patterns**: Singleton services accessed via `.shared`, following existing pattern [Source: CLAUDE.md#Key Patterns and Conventions]

### Service Integration Requirements
- **StoreKit 2**: Requires iOS 15.0+ with `#available` checks for backward compatibility [Source: Technology Stack Specification.md#iOS Application]
- **Combine Framework**: For reactive state updates following app patterns [Source: CLAUDE.md#State Management]
- **UserDefaults**: For local persistence of subscription state cache [Source: Technology Stack Specification.md#Local Data Persistence]

### File Locations
Based on Growth app architecture: [Source: CLAUDE.md#Core Architecture Pattern]
- `Growth/Core/Services/SubscriptionStateManager.swift` (new) - Main service in Core Services
- `Growth/Core/Models/SubscriptionState.swift` (new) - State models in Core Models  
- `Growth/Core/Models/SubscriptionStateCache.swift` (new) - Local cache models
- `Growth/Features/Settings/SettingsView.swift` (integrate) - UI integration point

### Integration with Existing Services
- **SubscriptionEntitlementService**: Located at `Growth/Core/Services/SubscriptionEntitlementService.swift`, handles feature access [Source: CLAUDE.md#Key Services]
- **StoreKitService**: From Story 23.2, provides transaction monitoring [Source: ai/stories/23.2.story.md]
- **PurchaseManager**: From Story 23.2, handles purchase orchestration [Source: ai/stories/23.2.story.md]

### Technical Constraints
- **Threading**: Firebase operations on background queues, UI updates on main thread [Source: CLAUDE.md#Threading Considerations]
- **Memory Management**: Use weak self captures in closures, proper Task cancellation [Source: CLAUDE.md#Performance Optimizations]
- **Error Handling**: Use Result types or completion handlers with optional errors [Source: CLAUDE.md#Key Patterns and Conventions]

### Testing Requirements
Based on app testing strategy: [Source: CLAUDE.md#Testing Strategy]
- Unit tests for Services and ViewModels using mock services
- Integration tests for service coordination scenarios
- iOS version compatibility testing for StoreKit 2 availability

## Tasks / Subtasks

### Task 1: Create Core State Management Service (AC: 1, 2, 5)
1.1. Create `SubscriptionStateManager.swift` with ObservableObject pattern [Source: CLAUDE.md#Key Patterns]
1.2. Implement iOS 15.0+ availability checks for StoreKit 2 features 
1.3. Set up Combine publishers for state updates following app patterns
1.4. Implement initialization with dependency injection for testability
1.5. Add proper Task-based async monitoring with cancellation support

### Task 2: Implement Local State Models (AC: 1, 3)
2.1. Create `SubscriptionState` struct with Codable conformance for caching
2.2. Create `SubscriptionStateCache` for UserDefaults persistence
2.3. Add timestamp-based cache invalidation logic (15 minute expiration)
2.4. Implement validation source tracking for local vs cached state
2.5. Add unit tests for state models using existing test patterns

### Task 3: Integrate with StoreKit Service (AC: 1, 2, 4)
3.1. Connect to StoreKitService transaction monitoring from Story 23.2
3.2. Implement local transaction validation without server calls
3.3. Handle subscription status updates from StoreKit transaction listener
3.4. Process renewal, cancellation, and expiration events locally
3.5. Add error handling for StoreKit unavailability scenarios

### Task 4: Coordinate with SubscriptionEntitlementService (AC: 3, 5)
4.1. Integrate with existing SubscriptionEntitlementService without breaking changes
4.2. Synchronize state between services using observer pattern
4.3. Handle cache conflicts with proper reconciliation logic
4.4. Ensure proper initialization order during app startup
4.5. Add integration tests for service coordination scenarios

### Task 5: Implement App Lifecycle Integration (AC: 4)
5.1. Add foreground/background state refresh using app lifecycle events
5.2. Integrate with Settings UI for subscription management display
5.3. Handle app termination and state persistence gracefully
5.4. Support paywall UI components with real-time state updates
5.5. Test state consistency across app restart scenarios

### Task 6: Local Caching and Persistence (AC: 5)
6.1. Implement UserDefaults-based state caching with versioning
6.2. Add cache invalidation logic for expired data
6.3. Handle cache corruption and recovery scenarios
6.4. Implement offline state management using cached data
6.5. Add unit tests for caching behavior and edge cases

## Testing Requirements

### Unit Tests
- [ ] Test SubscriptionStateManager initialization and state updates
- [ ] Test local transaction validation logic without server dependencies
- [ ] Test cache persistence and invalidation behavior
- [ ] Test iOS version compatibility and fallback scenarios
- [ ] Test Task cancellation and memory management

### Integration Tests
- [ ] Test StoreKitService integration for transaction monitoring
- [ ] Test SubscriptionEntitlementService coordination and state synchronization
- [ ] Test app lifecycle state management and persistence
- [ ] Test offline behavior with cached state data
- [ ] Test UI component integration with state updates

### Manual Testing
- [ ] Verify subscription state consistency across app restarts
- [ ] Test subscription renewal and expiration flows using local validation
- [ ] Verify offline behavior with cached subscription data
- [ ] Test integration with Settings UI for subscription display
- [ ] Verify proper fallback behavior on iOS < 15.0 devices

## Success Metrics
- Local subscription state consistency maintained across 99%+ of app sessions
- Transaction state updates processed within 1 second using local validation
- Zero local state management crashes or memory leaks
- Proper handling of all local subscription lifecycle events
- Smooth fallback behavior when server validation unavailable

## Dependencies
- **Story 23.0**: Firebase Functions infrastructure (for future server validation)
- **Story 23.2**: StoreKitService and PurchaseManager implementation (COMPLETE)
- **Existing Services**: SubscriptionEntitlementService integration

## Notes
This story focuses entirely on local state management and coordination, providing immediate value while preparing for server validation in Story 23.3b. The implementation prioritizes compatibility with existing services and follows established app patterns for service architecture and state management.

## Dev Agent Record

### Status: âœ… COMPLETE
### Completion Date: January 19, 2025
### Priority: High (Unblocks local subscription functionality)
### Story Points: 3
### Dependencies: Story 23.2 (Complete)

### Implementation Strategy
1. Local validation only - no server calls or Firebase dependencies
2. Full integration with existing SubscriptionEntitlementService
3. Prepare architecture for server validation enhancement in 23.3b
4. Follow established app patterns for service design and testing

### Technical Focus
- StoreKit 2 local transaction monitoring and validation
- Combine-based reactive state management
- Service coordination without breaking existing functionality
- Comprehensive offline state management with caching