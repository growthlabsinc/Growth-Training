import ActivityKit
import Foundation
import UIKit
import Firebase
import FirebaseFirestore
import FirebaseAuth

@available(iOS 16.1, *)
class LiveActivityManager: ObservableObject {
    static let shared = LiveActivityManager()
    
    @Published private(set) var currentActivity: Activity<TimerActivityAttributes>?
    
    private init() {}
    
    func startTimerActivity(
        methodId: String,
        methodName: String,
        startTime: Date,
        endTime: Date,
        duration: TimeInterval,
        sessionType: TimerActivityAttributes.ContentState.SessionType,
        timerType: String = "main"
    ) {
        print("üîµ LiveActivityManager: startTimerActivity called")
        print("  - Method: \(methodName) (ID: \(methodId))")
        print("  - Duration: \(duration)s, Type: \(sessionType)")
        print("  - Start: \(startTime), End: \(endTime)")
        print("üü¢ DEBUG: Time calculations:")
        print("  - Current time: \(Date())")
        print("  - Time since start: \(Date().timeIntervalSince(startTime))s")
        print("  - Time until end: \(endTime.timeIntervalSinceNow)s")
        
        guard ActivityAuthorizationInfo().areActivitiesEnabled else {
            print("‚ùå LiveActivityManager: Live Activities are NOT enabled in system settings")
            return
        }
        print("‚úÖ LiveActivityManager: Live Activities are enabled")
        
        Task {
            // Small delay to ensure app is stable before creating Live Activity
            // This helps prevent decoding errors when screen locks immediately
            try? await Task.sleep(nanoseconds: 50_000_000) // 0.05 seconds
            
            await endCurrentActivity()
            
            let attributes = TimerActivityAttributes(
                methodId: methodId,
                totalDuration: duration,
                timerType: timerType
            )
            
            let contentState = TimerActivityAttributes.ContentState(
                startedAt: startTime,
                pausedAt: nil, // Not paused when starting
                endTime: sessionType == .countdown ? endTime : nil,
                methodName: methodName,
                sessionType: sessionType,
                isCompleted: false,
                completionMessage: nil
            )
            
            do {
                print("üîµ LiveActivityManager: Creating Live Activity")
                
                // Calculate appropriate stale date - needs to be far in future to prevent freezing
                // Using 8 hours to prevent Live Activity from freezing during screen lock
                let staleDate: Date
                if sessionType == .countdown {
                    // For countdown timers, stale date should be well past end time
                    // to prevent freezing when screen is locked
                    staleDate = endTime.addingTimeInterval(28800) // 8 hours past end time
                } else {
                    // For countup timers, use a very long duration
                    staleDate = Date().addingTimeInterval(28800) // 8 hours from now
                }
                print("  - Stale date set to: \(staleDate) (in \(staleDate.timeIntervalSinceNow) seconds)")
                
                // Enable push updates for Live Activity
                let activity: Activity<TimerActivityAttributes>
                if #available(iOS 16.2, *) {
                    activity = try Activity<TimerActivityAttributes>.request(
                        attributes: attributes,
                        content: ActivityContent(state: contentState, staleDate: staleDate),
                        pushType: .token
                    )
                } else {
                    activity = try Activity<TimerActivityAttributes>.request(
                        attributes: attributes,
                        content: ActivityContent(state: contentState, staleDate: staleDate)
                    )
                }
                
                print("üü¢ DEBUG: Activity created successfully")
                print("  - Activity ID: \(activity.id)")
                print("  - Activity State: \(activity.activityState)")
                print("  - Content pausedAt: \(String(describing: activity.content.state.pausedAt))")
                print("  - Stale Date: \(activity.content.staleDate?.description ?? "nil")")
                
                await MainActor.run {
                    self.currentActivity = activity
                }
                
                print("‚úÖ LiveActivityManager: Started Live Activity with ID: \(activity.id)")
                // pushType is only available in iOS 16.2+
                // print("  - Push token enabled: \(activity.pushType == .token)")
                
                // Persist the Live Activity state to App Group for recovery
                AppGroupConstants.storeTimerState(
                    startTime: startTime,
                    endTime: endTime,
                    elapsedTime: 0,
                    isPaused: false,
                    methodName: methodName,
                    sessionType: sessionType.rawValue,
                    activityId: activity.id
                )
                print("üíæ LiveActivityManager: Persisted initial state to App Group")
                
                // Start monitoring the activity
                LiveActivityMonitor.shared.startMonitoring(activity: activity)
                
                // Start server-side push updates (no local updates)
                LiveActivityPushService.shared.startPushUpdates(for: activity)
                
                // Monitor activity state changes
                Task {
                    print("üü¢ DEBUG: Starting activity state monitoring")
                    for await state in activity.activityStateUpdates {
                        print("üîµ DEBUG: Activity state changed to: \(state)")
                        switch state {
                        case .active:
                            print("  ‚úÖ Activity is active")
                        case .stale:
                            print("  ‚ö†Ô∏è WARNING: Activity became STALE! This may cause freezing")
                            print("  - Current time: \(Date())")
                            print("  - Stale date was: \(activity.content.staleDate?.description ?? "unknown")")
                        case .ended:
                            print("  üî¥ Activity ended")
                        case .dismissed:
                            print("  üî¥ Activity dismissed")
                        @unknown default:
                            print("  ‚ùì Unknown state: \(state)")
                        }
                    }
                }
                
                // Register for push token updates
                Task {
                    await registerForPushUpdates(activity: activity)
                }
            } catch {
                print("‚ùå LiveActivityManager: Failed to start Live Activity")
                print("  - Error: \(error)")
                print("  - Description: \(error.localizedDescription)")
            }
        }
    }
    
    func updateActivity(isPaused: Bool, newEndTime: Date? = nil) {
        Task {
            guard let activity = currentActivity else {
                print("‚ùå DEBUG: No current activity to update")
                return
            }
            
            print("üîµ DEBUG: updateActivity called")
            print("  - isPaused parameter: \(isPaused)")
            print("  - Current activity pausedAt: \(String(describing: activity.content.state.pausedAt))")
            print("  - Activity state: \(activity.activityState)")
            print("  - Activity ID: \(activity.id)")
            
            var updatedState = activity.content.state
            let now = Date()
            
            if isPaused && activity.content.state.pausedAt == nil {
                // Pausing: Just set pausedAt timestamp
                print("üü° DEBUG: PAUSING Activity")
                print("  - Setting pausedAt to: \(now)")
                updatedState.pausedAt = now
            } else if !isPaused && activity.content.state.pausedAt != nil {
                // Resuming: Adjust end time for countdown timers
                print("üü¢ DEBUG: RESUMING Activity")
                if let pausedAt = activity.content.state.pausedAt,
                   updatedState.sessionType == .countdown,
                   let endTime = updatedState.endTime {
                    // Calculate pause duration and extend end time
                    let pauseDuration = now.timeIntervalSince(pausedAt)
                    updatedState.endTime = endTime.addingTimeInterval(pauseDuration)
                    print("  - Pause duration: \(pauseDuration)s")
                    print("  - New end time: \(updatedState.endTime!)")
                }
                updatedState.pausedAt = nil
            }
            
            if let newEndTime = newEndTime {
                updatedState.endTime = newEndTime
            }
            
            print("üîÑ LiveActivityManager: Sending update to Live Activity...")
            print("  - Final state: pausedAt=\(String(describing: updatedState.pausedAt))")
            print("  - startedAt: \(updatedState.startedAt)")
            print("  - endTime: \(String(describing: updatedState.endTime))")
            
            // Calculate stale date - must be far in future to prevent Live Activity freezing
            // iOS may stop updating the timer when approaching stale date, especially when locked
            // Based on research: Use very long stale dates to prevent freezing issues
            let staleDate = Date().addingTimeInterval(28800) // 8 hours from now
            
            // Update the Live Activity locally first for immediate feedback
            print("üü¢ DEBUG: About to update Live Activity")
            print("  - Stale date: \(staleDate) (\(staleDate.timeIntervalSinceNow / 3600) hours from now)")
            
            await activity.update(ActivityContent(state: updatedState, staleDate: staleDate))
            print("‚úÖ LiveActivityManager: Local update applied for \(activity.id) with staleDate: \(staleDate)")
            
            // Check if activity state changed after update
            print("üü¢ DEBUG: Post-update activity state: \(activity.activityState)")
            if activity.activityState == .stale {
                print("‚ö†Ô∏è WARNING: Activity is STALE after update! This will cause freezing")
            }
            
            // Persist the updated state to App Group
            AppGroupConstants.storeTimerState(
                startTime: updatedState.startedAt,
                endTime: updatedState.endTime ?? Date(),
                elapsedTime: updatedState.getElapsedTimeInSeconds(),
                isPaused: updatedState.pausedAt != nil,
                methodName: updatedState.methodName,
                sessionType: updatedState.sessionType.rawValue,
                activityId: activity.id
            )
            print("üíæ LiveActivityManager: Persisted updated state to App Group")
            
            // Then try to send push update for server-side management
            // This ensures the Live Activity continues updating even after 30 seconds
            print("üü¢ DEBUG: Sending push update for server-side management")
            await LiveActivityPushService.shared.sendStateChangeUpdate(for: activity, isPaused: isPaused)
            print("‚úÖ LiveActivityManager: Push update sent for \(activity.id)")
            
            // Debug print the full state
            print("üîç DEBUG: Full activity state after update:")
            debugPrintActivityState(activity)
        }
    }
    
    func endCurrentActivity(immediately: Bool = false) async {
        guard let activity = currentActivity else { return }
        
        print("üî¥ LiveActivityManager: Ending current activity \(activity.id) (immediately: \(immediately))")
        
        // Stop monitoring
        LiveActivityMonitor.shared.stopMonitoring(activityId: activity.id)
        
        // Stop push updates
        LiveActivityPushService.shared.stopPushUpdates()
        
        let now = Date()
        
        let finalState = TimerActivityAttributes.ContentState(
            startedAt: activity.content.state.startedAt,
            pausedAt: nil,
            endTime: now,
            methodName: activity.content.state.methodName,
            sessionType: activity.content.state.sessionType,
            isCompleted: false,
            completionMessage: nil
        )
        
        if immediately {
            // Dismiss immediately when stop is pressed from Live Activity
            await activity.end(
                ActivityContent(state: finalState, staleDate: now),
                dismissalPolicy: .immediate
            )
            print("‚úÖ LiveActivityManager: Activity dismissed immediately")
        } else {
            // Use dismissal policy with a 2 second delay for smoother UX
            let dismissalDate = now.addingTimeInterval(2)
            await activity.end(
                ActivityContent(state: finalState, staleDate: dismissalDate),
                dismissalPolicy: .after(dismissalDate)
            )
            print("‚úÖ LiveActivityManager: Activity scheduled for dismissal at \(dismissalDate)")
        }
        
        await MainActor.run {
            self.currentActivity = nil
        }
    }
    
    func completeActivity(withMessage message: String? = nil) async {
        guard let activity = currentActivity else { return }
        
        print("‚úÖ LiveActivityManager: Completing activity \(activity.id)")
        
        let now = Date()
        
        // First show completion state
        let completionState = TimerActivityAttributes.ContentState(
            startedAt: activity.content.state.startedAt,
            pausedAt: nil,
            endTime: now,
            methodName: activity.content.state.methodName,
            sessionType: activity.content.state.sessionType,
            isCompleted: true,
            completionMessage: message
        )
        
        // Set stale date far in future for completion state (it shouldn't go stale)
        let completionStaleDate = now.addingTimeInterval(3600) // 1 hour to prevent freezing
        await activity.update(ActivityContent(state: completionState, staleDate: completionStaleDate))
        
        // Wait 5 seconds to show completion, then dismiss
        try? await Task.sleep(nanoseconds: 5_000_000_000)
        
        // Stop monitoring
        LiveActivityMonitor.shared.stopMonitoring(activityId: activity.id)
        
        // Stop push updates
        LiveActivityPushService.shared.stopPushUpdates()
        
        // End with dismissal policy after showing completion
        let dismissalDate = Date().addingTimeInterval(1)
        await activity.end(
            ActivityContent(state: completionState, staleDate: dismissalDate),
            dismissalPolicy: .after(dismissalDate)
        )
        
        await MainActor.run {
            self.currentActivity = nil
        }
        
        // Clear persisted state
        AppGroupConstants.clearTimerState()
        print("üóëÔ∏è LiveActivityManager: Cleared persisted state from App Group")
    }
    
    func endAllActivities() async {
        for activity in Activity<TimerActivityAttributes>.activities {
            let finalState = TimerActivityAttributes.ContentState(
                startedAt: activity.content.state.startedAt,
                pausedAt: nil,
                endTime: Date(),
                methodName: activity.content.state.methodName,
                sessionType: activity.content.state.sessionType,
                isCompleted: false,
                completionMessage: nil
            )
            await activity.end(ActivityContent(state: finalState, staleDate: nil), dismissalPolicy: .immediate)
        }
        
        await MainActor.run {
            self.currentActivity = nil
        }
    }
    
    // MARK: - Recovery Methods
    
    private func recoverFromStaleActivity(activity: Activity<TimerActivityAttributes>, updatedState: TimerActivityAttributes.ContentState) async {
        print("üîÑ LiveActivityManager: Starting recovery process for stale activity")
        
        // First, try to end the existing activity
        await activity.end(ActivityContent(state: updatedState, staleDate: Date()), dismissalPolicy: .immediate)
        print("‚úÖ LiveActivityManager: Ended stale activity")
        
        // Clear current activity reference
        await MainActor.run {
            self.currentActivity = nil
        }
        
        // Wait a moment before restarting
        try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
        
        // Restart the Live Activity with current state
        startTimerActivity(
            methodId: activity.attributes.methodId,
            methodName: updatedState.methodName,
            startTime: updatedState.startedAt,
            endTime: updatedState.endTime ?? Date().addingTimeInterval(activity.attributes.totalDuration),
            duration: activity.attributes.totalDuration,
            sessionType: updatedState.sessionType,
            timerType: activity.attributes.timerType
        )
        
        // Update the new activity to match the current state
        if let newActivity = currentActivity {
            await newActivity.update(ActivityContent(state: updatedState, staleDate: Date().addingTimeInterval(120)))
            print("‚úÖ LiveActivityManager: Recovered and updated new activity")
        }
    }
    
    // MARK: - Push Notification Support
    
    private func registerForPushUpdates(activity: Activity<TimerActivityAttributes>) async {
        print("üîî LiveActivityManager: Starting push token registration for activity \(activity.id)")
        
        // Add timeout to prevent hanging if token never arrives
        let tokenTask = Task {
            // Wait for push tokens
            for await pushToken in activity.pushTokenUpdates {
                let tokenString = pushToken.map { String(format: "%02x", $0) }.joined()
                print("‚úÖ Live Activity push token received: \(tokenString)")
                
                // Store the push token in Firestore
                await storeLiveActivityPushToken(
                    activityId: activity.id,
                    pushToken: tokenString,
                    methodId: activity.attributes.methodId
                )
                
                // Continue listening for token updates (they can change)
            }
            print("‚ÑπÔ∏è LiveActivityManager: Push token updates stream ended for activity \(activity.id)")
        }
        
        // Log if no token received after 10 seconds (informational only)
        Task {
            try? await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
            if tokenTask.isCancelled == false {
                print("‚ÑπÔ∏è LiveActivityManager: No push token received yet after 10 seconds (this is normal and won't affect timer functionality)")
                // Continue listening - token may arrive later
            }
        }
    }
    
    private func storeLiveActivityPushToken(activityId: String, pushToken: String, methodId: String) async {
        guard let userId = Auth.auth().currentUser?.uid else {
            print("No authenticated user to store Live Activity push token")
            return
        }
        
        let db = Firestore.firestore()
        
        // Detect current environment to help with APNs routing
        let environment = EnvironmentDetector.detectEnvironment()
        let bundleId = Bundle.main.bundleIdentifier ?? "unknown"
        
        let data: [String: Any] = [
            "activityId": activityId,
            "pushToken": pushToken,
            "methodId": methodId,
            "userId": userId,
            "createdAt": FieldValue.serverTimestamp(),
            "platform": "ios",
            "environment": environment.rawValue,
            "bundleId": bundleId,
            "widgetBundleId": "\(bundleId).GrowthTimerWidget"
        ]
        
        do {
            print("üîµ LiveActivityManager: Attempting to write to Firestore...")
            try await db.collection("liveActivityTokens").document(activityId).setData(data)
            print("‚úÖ LiveActivityManager: Successfully stored Live Activity push token")
            print("  - Collection: liveActivityTokens")
            print("  - Document ID: \(activityId)")
            print("  - Data stored: \(data)")
        } catch {
            print("‚ùå LiveActivityManager: Failed to store Live Activity push token")
            print("  - Error: \(error)")
            print("  - Error details: \(error.localizedDescription)")
            if let firestoreError = error as NSError? {
                print("  - Error code: \(firestoreError.code)")
                print("  - Error domain: \(firestoreError.domain)")
            }
        }
    }
    
    // MARK: - Debug Methods
    
    private func debugPrintActivityState(_ activity: Activity<TimerActivityAttributes>) {
        print("  üìã Activity Details:")
        print("    - ID: \(activity.id)")
        print("    - State: \(activity.activityState)")
        print("    - Stale Date: \(activity.content.staleDate?.description ?? "nil")")
        print("    - Content State:")
        print("      - pausedAt: \(String(describing: activity.content.state.pausedAt))")
        print("      - startedAt: \(activity.content.state.startedAt)")
        print("      - endTime: \(String(describing: activity.content.state.endTime))")
        print("      - sessionType: \(activity.content.state.sessionType)")
        print("      - elapsed time: \(activity.content.state.getElapsedTimeInSeconds())s")
        print("      - is running: \(activity.content.state.isRunning())")
    }
    
    func debugPrintCurrentState() {
        print("üîç ==== LIVE ACTIVITY DEBUG STATE =====")
        print("üîµ Current Activities:")
        
        let activities = Activity<TimerActivityAttributes>.activities
        print("  - Total activities: \(activities.count)")
        
        for (index, activity) in activities.enumerated() {
            print("\n  Activity \(index + 1):")
            print("    - ID: \(activity.id)")
            print("    - State: \(activity.activityState)")
            // pushType is only available in iOS 16.2+
            // if #available(iOS 16.2, *) {
            //     print("    - Push Type: \(String(describing: activity.pushType))")
            // }
            print("    - Content State:")
            print("      - pausedAt: \(String(describing: activity.content.state.pausedAt))")
            print("      - sessionType: \(activity.content.state.sessionType)")
            print("      - methodName: \(activity.content.state.methodName)")
            print("      - startedAt: \(activity.content.state.startedAt)")
            print("      - endTime: \(String(describing: activity.content.state.endTime))")
            if activity.content.state.sessionType == .countdown {
                print("      - remaining time: \(activity.content.state.getRemainingTimeInSeconds())s")
            } else {
                print("      - elapsed time: \(activity.content.state.getElapsedTimeInSeconds())s")
            }
        }
        
        if currentActivity != nil {
            print("\n‚úÖ Current activity is set")
        } else {
            print("\n‚ö†Ô∏è No current activity set")
        }
        print("=====================================\n")
    }
    
    // Handle push notification actions
    func handlePushAction(_ action: String) {
        guard currentActivity != nil else { return }
        
        switch action {
        case "pause":
            updateActivity(isPaused: true)
        case "resume":
            updateActivity(isPaused: false)
        case "stop":
            Task {
                await endCurrentActivity()
            }
        default:
            break
        }
    }
}